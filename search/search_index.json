{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Arquitecturas de aplicaciones en iOS \u00b6 En este \"mini-bloque\" veremos una breve introducci\u00f3n a las recomendaciones habituales sobre c\u00f3mo estructurar una aplicaci\u00f3n en iOS. Veremos los problemas habituales de la arquitectura por defecto, MVC, y algunas alternativas. Tambi\u00e9n veremos una introducci\u00f3n a SwiftUI, que nos obliga a estructurar de otra forma las aplicaciones.","title":"Arquitecturas de aplicaciones en iOS"},{"location":"#arquitecturas-de-aplicaciones-en-ios","text":"En este \"mini-bloque\" veremos una breve introducci\u00f3n a las recomendaciones habituales sobre c\u00f3mo estructurar una aplicaci\u00f3n en iOS. Veremos los problemas habituales de la arquitectura por defecto, MVC, y algunas alternativas. Tambi\u00e9n veremos una introducci\u00f3n a SwiftUI, que nos obliga a estructurar de otra forma las aplicaciones.","title":"Arquitecturas de aplicaciones en iOS"},{"location":"arquitecturas/1_intro_arquitecturas/","text":"En este tema veremos algo que no est\u00e1 directamente relacionado con la persistencia, pero que es pertinente en este punto del curso. Hasta ahora hemos visto multitud de tecnolog\u00edas para desarrollar aplicaciones en iOS, pero una cosa que nos falta es saber c\u00f3mo estructurar el c\u00f3digo de la aplicaci\u00f3n para hacerlo lo m\u00e1s claro, mantenible y testable que sea posible. Ya vimos al comienzo del curso que la arquitectura recomendada por Apple es Modelo/Vista/Controlador, pero aunque es muy apropiada para ejemplos y para aplicaciones peque\u00f1as, con aplicaciones m\u00e1s grandes presenta algunos problemas. Primero veremos cu\u00e1les son estos problemas y c\u00f3mo solucionarlos aunque sea parcialmente y luego abordaremos otras arquitecturas que se han propuesto como alternativas al cl\u00e1sico MVC.","title":"Introducci\u00f3n"},{"location":"arquitecturas/2_MVC/","text":"Los problemas de MVC \u00b6 En teor\u00eda la estructura de una aplicaci\u00f3n iOS con MVC deber\u00eda ser sencilla y \"limpia\", ya que cada uno de los tres componentes tiene una responsabilidad separada. En la pr\u00e1ctica, la principal fuente de problemas de esta arquitectura es el controlador . Por un lado, el UIViewController est\u00e1 tan unido a la vista que acaba siendo parte de ella en lugar de un componente separado. En la realidad la arquitectura de muchas aplicaciones iOS acaba pareci\u00e9ndose m\u00e1s a la siguiente figura que a la anterior: Al estar tan acoplado el controlador a la vista se hace casi imposible hacer testing del controlador en s\u00ed, sin probar la interfaz de usuario, ya que tendr\u00edamos que hacer un mock de todos los componentes de la vista que interact\u00faan con el controlador. Por otro lado es f\u00e1cil \"dejarse llevar\" y acabar asign\u00e1ndole demasiadas responsabilidades al controlador: colocar en \u00e9l l\u00f3gica de negocio, hacer que sea el datasource o el delegate de las tablas que contiene,... Esto da lugar a lo que de modo ir\u00f3nico se conoce como massive view controller . Casi todos los tutoriales y ejemplos sobre frameworks o APIs de iOS que encontrar\u00e9is en la web o en los libros tienen este problema, incluyendo muchas veces el material que os damos en este curso. Como el objetivo del tutorial o del ejemplo es aprender sobre el framework /API que no conoces, se tiende a poner todo el c\u00f3digo en el view controller , evitando crear clases adicionales que a\u00f1adir\u00edan complejidad al ejemplo y distraer\u00edan del objetivo principal. Pero por desgracia el resultado final es un Massive View Controller . Para solucionar todos estos problemas podemos usar una arquitectura distinta a MVC, como veremos en apartados posteriores. Pero no todo son problemas en MVC tal como lo propone Apple: tiene la ventaja de estar especialmente adaptado a la filosof\u00eda de la plataforma, los frameworks y los APIs de iOS, y adem\u00e1s es una arquitectura sencilla. Una alternativa ser\u00eda continuar us\u00e1ndolo pero intentar \"aligerar\" el controlador en la medida de lo posible para hacer el c\u00f3digo m\u00e1s mantenible. Vamos a ver c\u00f3mo podr\u00edamos hacerlo. Controladores \"ligeros\" \u00b6 B\u00e1sicamente la idea es dejar en el controlador el m\u00ednimo de c\u00f3digo imprescindible para coordinarse con el modelo y con la vista, que es la que deber\u00eda ser su \u00fanica labor. Esto no es m\u00e1s que una aplicaci\u00f3n del \"Principio de responsabilidad \u00fanica\" (Single Responsibility Principe), un principio b\u00e1sico en el dise\u00f1o y desarrollo de software que sostiene que cada componente deber\u00eda tener una \u00fanica responsabilidad o funcionalidad en el sistema . Esto no solo mejora la estructura del c\u00f3digo, sino que tambi\u00e9n facilita el testing y mejora la mantenibilidad de la aplicaci\u00f3n. Si \"nos dejamos llevar\" y colocamos todo el c\u00f3digo de la aplicaci\u00f3n en el view controller , al final puede acabar teniendo las siguientes responsabilidades: Almacenar temporalmente y modificar los datos de la aplicaci\u00f3n Implementar al menos parte de la l\u00f3gica de negocio, que deber\u00eda estar \u00fanicamente en las clases del modelo Implementar la persistencia de datos. Si adem\u00e1s usamos Core Data y necesitamos listar datos con un fetched results controller , el view controller acaba teniendo que convertirse en su delegate . En caso de tener una tabla: T\u00edpicamente es datasource y delegate de la misma Al ser el datasource , se tiene que encargar de rellenar todos los datos de cada celda, por lo que tiene que conocer su estructura El view controller acaba convirti\u00e9ndose la mayor\u00eda de veces en el delegate de los componentes de interfaz que requieren uno, por ejemplo los sliders o los datepickers . Muchas veces cuando de un view controller se salta a otro este le pasa los datos fijando propiedades en el view controller destino. Eso implica un conocimiento de la estructura interna de este controller . B\u00e1sicamente la soluci\u00f3n es relativamente de \"sentido com\u00fan\" y consiste en extraer todas estas funcionalidades a clases/ structs adicionales. Vamos a ver algunas ideas gen\u00e9ricas de c\u00f3mo se podr\u00edan hacer estas refactorizaciones. Separaci\u00f3n de los datasources / delegates \u00b6 Vamos a ver c\u00f3mo se podr\u00eda extraer el datasource de una tabla. Un delegate ser\u00eda similar. Intentaremos hacer una clase gen\u00e9rica que nos pueda servir en varios proyectos. Dicha clase: Por supuesto implementa los m\u00e9todos del protocolo UITableViewDataSource Contiene un array con los objetos a mostrar, ya que es la forma m\u00e1s sencilla de representar los datos. Acepta en el constructor una clausura que se encarga de rellenar los campos de una celda a partir de un objeto import Foundation import UIKit class ListaItemsDataSource < Item > : NSObject , UITableViewDataSource { private var items : [ Item ] private var idCelda : String private var configurarCelda : ( UITableViewCell , Item ) -> Void init ( listaItems : [ Item ], idCelda : String , configurarCelda : @ escaping ( UITableViewCell , Item ) -> Void ) { self . items = listaItems self . idCelda = idCelda self . configurarCelda = configurarCelda } func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { return items . count } func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { let cell = tableView . dequeueReusableCell ( withIdentifier : self . idCelda , for : indexPath ) self . configurarCelda ( cell , self . items [ indexPath . row ]) return cell } } Y aqu\u00ed tenemos un view controller de ejemplo que hace uso de esta clase. Por ejemplo supongamos que queremos mostrar una lista de objetos Persona class MiController : UIViewController { var miDataSource : ListaItemsDataSource < Usuario > ! override func viewDidLoad () { super . viewDidLoad () //Tendr\u00edamos que obtener los datos de alg\u00fan sitio, p.ej. de Core Data let lista = ... self . miDataSource = ListaItemsDataSource < Usuario >( listaItems : lista , idCelda : \"MiCelda\" ) { celda , persona in celda . textLabel ?. text = persona . nombre let df = DateFormatter () df . dateFormat = \"dd/MM/yyyy\" let fechaString = df . string ( from : persona . fechaNacimiento ) celda . detailTextLabel ?. text = fechaString } self . tableView . dataSource = self . miDataSource } } Extraer el c\u00f3digo de configuraci\u00f3n de la celda \u00b6 En el c\u00f3digo anterior el View Controller sigue teniendo que ocuparse de rellenar los campos de la celda, lo que hace que tenga que conocer su estructura: en el ejemplo, que la celda tiene un textLabel y un detailTextLabel y tambi\u00e9n que tenga que ocuparse de formatear los datos, por ejemplo la fecha. Podemos encapsular la informaci\u00f3n sobre la \"estructura interna\" de la celda en una nueva clase, que en MVC pertenecer\u00eda a la vista. class CeldaPersona : UITableViewCell { static let idCelda = \"MiCelda\" var nombre : String ? { didSet { self . textLabel ?. text = self . nombre } } var fecha : Date ? { didSet { let df = DateFormatter () df . dateStyle = . short self . detailTextLabel ?. text = df . string ( from : self . fecha !) } } } N\u00f3tese que ahora \"desde fuera\" para configurar la celda lo \u00fanico que hay que hacer es fijar el valor de las propiedades \"texto\" y \"fecha\". Los didSet se encargar\u00e1n autom\u00e1ticamente de rellenar los campos de la celda con el formato adecuado. De este modo el view controller quedar\u00eda a\u00fan m\u00e1s sencillo class MiController : UIViewController { var miDataSource : ListaItemsDataSource < Usuario > ! override func viewDidLoad () { super . viewDidLoad () //Tendr\u00edamos que obtener los datos de alg\u00fan sitio, p.ej. de Core Data let lista = ... self . miDataSource = ListaItemsDataSource < Usuario >( listaItems : lista , idCelda : \"MiCelda\" ) { celda , persona in if let celdaPersona = celda as ? CeldaPersona { celdaPersona . nombre = persona . nombre celdaPersona . fecha = persona . fechaNacimiento } } self . tableView . dataSource = self . miDataSource } } Para que el cast de celda as CeldaPersona pueda tener \u00e9xito, en Xcode habr\u00e1 que seleccionar la celda prototipo en el storyboard y cambiar en el \"identity inspector\" del panel derecho la clase de la celda por CeldaPersona .","title":"MVC"},{"location":"arquitecturas/2_MVC/#los-problemas-de-mvc","text":"En teor\u00eda la estructura de una aplicaci\u00f3n iOS con MVC deber\u00eda ser sencilla y \"limpia\", ya que cada uno de los tres componentes tiene una responsabilidad separada. En la pr\u00e1ctica, la principal fuente de problemas de esta arquitectura es el controlador . Por un lado, el UIViewController est\u00e1 tan unido a la vista que acaba siendo parte de ella en lugar de un componente separado. En la realidad la arquitectura de muchas aplicaciones iOS acaba pareci\u00e9ndose m\u00e1s a la siguiente figura que a la anterior: Al estar tan acoplado el controlador a la vista se hace casi imposible hacer testing del controlador en s\u00ed, sin probar la interfaz de usuario, ya que tendr\u00edamos que hacer un mock de todos los componentes de la vista que interact\u00faan con el controlador. Por otro lado es f\u00e1cil \"dejarse llevar\" y acabar asign\u00e1ndole demasiadas responsabilidades al controlador: colocar en \u00e9l l\u00f3gica de negocio, hacer que sea el datasource o el delegate de las tablas que contiene,... Esto da lugar a lo que de modo ir\u00f3nico se conoce como massive view controller . Casi todos los tutoriales y ejemplos sobre frameworks o APIs de iOS que encontrar\u00e9is en la web o en los libros tienen este problema, incluyendo muchas veces el material que os damos en este curso. Como el objetivo del tutorial o del ejemplo es aprender sobre el framework /API que no conoces, se tiende a poner todo el c\u00f3digo en el view controller , evitando crear clases adicionales que a\u00f1adir\u00edan complejidad al ejemplo y distraer\u00edan del objetivo principal. Pero por desgracia el resultado final es un Massive View Controller . Para solucionar todos estos problemas podemos usar una arquitectura distinta a MVC, como veremos en apartados posteriores. Pero no todo son problemas en MVC tal como lo propone Apple: tiene la ventaja de estar especialmente adaptado a la filosof\u00eda de la plataforma, los frameworks y los APIs de iOS, y adem\u00e1s es una arquitectura sencilla. Una alternativa ser\u00eda continuar us\u00e1ndolo pero intentar \"aligerar\" el controlador en la medida de lo posible para hacer el c\u00f3digo m\u00e1s mantenible. Vamos a ver c\u00f3mo podr\u00edamos hacerlo.","title":"Los problemas de MVC"},{"location":"arquitecturas/2_MVC/#controladores-ligeros","text":"B\u00e1sicamente la idea es dejar en el controlador el m\u00ednimo de c\u00f3digo imprescindible para coordinarse con el modelo y con la vista, que es la que deber\u00eda ser su \u00fanica labor. Esto no es m\u00e1s que una aplicaci\u00f3n del \"Principio de responsabilidad \u00fanica\" (Single Responsibility Principe), un principio b\u00e1sico en el dise\u00f1o y desarrollo de software que sostiene que cada componente deber\u00eda tener una \u00fanica responsabilidad o funcionalidad en el sistema . Esto no solo mejora la estructura del c\u00f3digo, sino que tambi\u00e9n facilita el testing y mejora la mantenibilidad de la aplicaci\u00f3n. Si \"nos dejamos llevar\" y colocamos todo el c\u00f3digo de la aplicaci\u00f3n en el view controller , al final puede acabar teniendo las siguientes responsabilidades: Almacenar temporalmente y modificar los datos de la aplicaci\u00f3n Implementar al menos parte de la l\u00f3gica de negocio, que deber\u00eda estar \u00fanicamente en las clases del modelo Implementar la persistencia de datos. Si adem\u00e1s usamos Core Data y necesitamos listar datos con un fetched results controller , el view controller acaba teniendo que convertirse en su delegate . En caso de tener una tabla: T\u00edpicamente es datasource y delegate de la misma Al ser el datasource , se tiene que encargar de rellenar todos los datos de cada celda, por lo que tiene que conocer su estructura El view controller acaba convirti\u00e9ndose la mayor\u00eda de veces en el delegate de los componentes de interfaz que requieren uno, por ejemplo los sliders o los datepickers . Muchas veces cuando de un view controller se salta a otro este le pasa los datos fijando propiedades en el view controller destino. Eso implica un conocimiento de la estructura interna de este controller . B\u00e1sicamente la soluci\u00f3n es relativamente de \"sentido com\u00fan\" y consiste en extraer todas estas funcionalidades a clases/ structs adicionales. Vamos a ver algunas ideas gen\u00e9ricas de c\u00f3mo se podr\u00edan hacer estas refactorizaciones.","title":"Controladores \"ligeros\""},{"location":"arquitecturas/2_MVC/#separacion-de-los-datasourcesdelegates","text":"Vamos a ver c\u00f3mo se podr\u00eda extraer el datasource de una tabla. Un delegate ser\u00eda similar. Intentaremos hacer una clase gen\u00e9rica que nos pueda servir en varios proyectos. Dicha clase: Por supuesto implementa los m\u00e9todos del protocolo UITableViewDataSource Contiene un array con los objetos a mostrar, ya que es la forma m\u00e1s sencilla de representar los datos. Acepta en el constructor una clausura que se encarga de rellenar los campos de una celda a partir de un objeto import Foundation import UIKit class ListaItemsDataSource < Item > : NSObject , UITableViewDataSource { private var items : [ Item ] private var idCelda : String private var configurarCelda : ( UITableViewCell , Item ) -> Void init ( listaItems : [ Item ], idCelda : String , configurarCelda : @ escaping ( UITableViewCell , Item ) -> Void ) { self . items = listaItems self . idCelda = idCelda self . configurarCelda = configurarCelda } func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { return items . count } func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { let cell = tableView . dequeueReusableCell ( withIdentifier : self . idCelda , for : indexPath ) self . configurarCelda ( cell , self . items [ indexPath . row ]) return cell } } Y aqu\u00ed tenemos un view controller de ejemplo que hace uso de esta clase. Por ejemplo supongamos que queremos mostrar una lista de objetos Persona class MiController : UIViewController { var miDataSource : ListaItemsDataSource < Usuario > ! override func viewDidLoad () { super . viewDidLoad () //Tendr\u00edamos que obtener los datos de alg\u00fan sitio, p.ej. de Core Data let lista = ... self . miDataSource = ListaItemsDataSource < Usuario >( listaItems : lista , idCelda : \"MiCelda\" ) { celda , persona in celda . textLabel ?. text = persona . nombre let df = DateFormatter () df . dateFormat = \"dd/MM/yyyy\" let fechaString = df . string ( from : persona . fechaNacimiento ) celda . detailTextLabel ?. text = fechaString } self . tableView . dataSource = self . miDataSource } }","title":"Separaci\u00f3n de los datasources/delegates"},{"location":"arquitecturas/2_MVC/#extraer-el-codigo-de-configuracion-de-la-celda","text":"En el c\u00f3digo anterior el View Controller sigue teniendo que ocuparse de rellenar los campos de la celda, lo que hace que tenga que conocer su estructura: en el ejemplo, que la celda tiene un textLabel y un detailTextLabel y tambi\u00e9n que tenga que ocuparse de formatear los datos, por ejemplo la fecha. Podemos encapsular la informaci\u00f3n sobre la \"estructura interna\" de la celda en una nueva clase, que en MVC pertenecer\u00eda a la vista. class CeldaPersona : UITableViewCell { static let idCelda = \"MiCelda\" var nombre : String ? { didSet { self . textLabel ?. text = self . nombre } } var fecha : Date ? { didSet { let df = DateFormatter () df . dateStyle = . short self . detailTextLabel ?. text = df . string ( from : self . fecha !) } } } N\u00f3tese que ahora \"desde fuera\" para configurar la celda lo \u00fanico que hay que hacer es fijar el valor de las propiedades \"texto\" y \"fecha\". Los didSet se encargar\u00e1n autom\u00e1ticamente de rellenar los campos de la celda con el formato adecuado. De este modo el view controller quedar\u00eda a\u00fan m\u00e1s sencillo class MiController : UIViewController { var miDataSource : ListaItemsDataSource < Usuario > ! override func viewDidLoad () { super . viewDidLoad () //Tendr\u00edamos que obtener los datos de alg\u00fan sitio, p.ej. de Core Data let lista = ... self . miDataSource = ListaItemsDataSource < Usuario >( listaItems : lista , idCelda : \"MiCelda\" ) { celda , persona in if let celdaPersona = celda as ? CeldaPersona { celdaPersona . nombre = persona . nombre celdaPersona . fecha = persona . fechaNacimiento } } self . tableView . dataSource = self . miDataSource } } Para que el cast de celda as CeldaPersona pueda tener \u00e9xito, en Xcode habr\u00e1 que seleccionar la celda prototipo en el storyboard y cambiar en el \"identity inspector\" del panel derecho la clase de la celda por CeldaPersona .","title":"Extraer el c\u00f3digo de configuraci\u00f3n de la celda"},{"location":"arquitecturas/3_MVP/","text":"Este patr\u00f3n de dise\u00f1o soluciona algunos de los problemas que tiene el MVC \"al estilo Apple\". El nuevo componente, llamado presenter se encarga de la l\u00f3gica de presentaci\u00f3n , y debe ser independiente de la tecnolog\u00eda que se est\u00e9 usando para la vista, que en iOS ser\u00e1 UIKit . La l\u00f3gica de presentaci\u00f3n engloba todas las operaciones necesarias para formatear los datos del modelo de modo que se puedan visualizar adecuadamente. Por ejemplo es posible que el modelo nos devuelva la distancia total de una ruta, y queramos que se pueda visualizar en metros o kil\u00f3metros. La conversi\u00f3n de unidades ser\u00eda responsabilidad del presenter . A primera vista el diagrama de componentes anterior parece muy similar al original de MVC, simplemente sustituyendo el controller por el presenter . No obstante, el que el presenter deba ser independiente de la tecnolog\u00eda de la vista tiene un impacto bastante importante en el c\u00f3digo. En las aplicaciones debemos seguir usando UIViewControllers , ya que son una parte b\u00e1sica de la plataforma. Sin embargo esta clase no es totalmente independiente de la tecnolog\u00eda de la vista, porque est\u00e1 \u00edntimamente unida a ella. De hecho, esto era uno de los problemas que ten\u00edamos en el MVC \"estilo Apple\". Por eso, en MVP consideraremos al view controller como parte de la vista . Es decir, el presenter de ning\u00fan modo es el antiguo controller bajo otro nombre, sino algo totalmente distinto. Vamos a verlo a trav\u00e9s de un ejemplo. Usaremos la aplicaci\u00f3n UAdivino , que fue nuestra primera aplicaci\u00f3n iOS en Swift. Recordemos que se trata de una app a la que se le \"formula una pregunta\" ( \u00bfAprender\u00e9 Swift? ) y nos da una contestaci\u00f3n positiva o negativa ( claro que s\u00ed , o ni de casualidad ). Vamos a hacer que si la contestaci\u00f3n es positiva se muestre en color verde y si es negativa en color rojo. Lo primero que vamos a hacer es formalizar la interfaz de los tres componentes, modelo, vista y presentador, usando protocolos. El diagrama de componentes quedar\u00eda del siguiente modo: Cuando se pulsa el bot\u00f3n de \"obtener respuesta\" la vista llama a solicitarRespuesta() del presentador . Este a su vez le pide al modelo que \"haga el trabajo\", generando una respuesta al azar. La respuesta contiene un texto y un booleano indicando si es positiva o negativa. Con este \u00faltimo el presentador calcula el color (verde o rojo, respectivamente), y le pasa texto y color a la vista para que lo muestre. En este caso la \"l\u00f3gica de presentaci\u00f3n\" consiste simplemente en calcular el color correspondiente a la respuesta. Al ser este un ejemplo muy sencillo el modelo no necesita notificaciones para \"avisar\" al presentador de que hay datos que mostrar. Una aplicaci\u00f3n que hiciera una b\u00fasqueda en un servicio web llamar\u00eda a un callback del presenter cuando se hubieran recibido los datos. Pod\u00e9is ver el c\u00f3digo fuente completo en el repositorio de GitHub. Ensamblado de la arquitectura \u00b6 vista y presentador deben comunicar el uno con el otro, as\u00ed que cada uno debe tener una referencia al otro.","title":"MVP"},{"location":"arquitecturas/3_MVP/#ensamblado-de-la-arquitectura","text":"vista y presentador deben comunicar el uno con el otro, as\u00ed que cada uno debe tener una referencia al otro.","title":"Ensamblado de la arquitectura"},{"location":"arquitecturas/4_MVVM/","text":"MVVM vs. MVP \u00b6 El patr\u00f3n de dise\u00f1o Model/View/ViewModel es muy similar al MVP que vimos en el apartado anterior. De hecho, el ViewModel tiene m\u00e1s o menos la misma funcionalidad que el presenter , implementar la l\u00f3gica de presentaci\u00f3n y aislarla de la tecnolog\u00eda concreta usada para la presentaci\u00f3n. \u00bfD\u00f3nde est\u00e1 la diferencia entonces?. En que MVVM soluciona uno de los principales problemas que tiene MVP, el acoplamiento entre vista y presenter . Como estuvimos discutiendo, la vista y el presenter deben \"conocerse\" mutuamente, ya que la vista debe comunicarle a este las acciones del usuario, y el presenter enviarle a la vista los datos a mostrar. Ya hemos visto en el c\u00f3digo de ejemplo de MVP que en la vista hay una referencia al presenter y viceversa. Eso quiere decir que no es sencillo cambiar la implementaci\u00f3n de uno de los dos sin afectar al otro. En MVVM no hay acoplamiento entre vista y viewmodel , y lo vamos a evitar usando bindings , es decir, vinculaci\u00f3n autom\u00e1tica entre los datos del viewmodel y la vista, de manera que cuando cambie alguno de ellos se modifique autom\u00e1ticamente la otra. Esto permite que el c\u00f3digo quede mucho m\u00e1s \"limpio\", ya que no hay que actualizar el otro componente de modo expl\u00edcito. En iOS podemos usar el framework Combine para hacer esta vinculaci\u00f3n. Combine es un framework encuadrado en lo que se conoce com\u00fanmente como \"programaci\u00f3n funcional reactiva\". Si no has o\u00eddo nunca este t\u00e9rmino no te preocupes, aqu\u00ed solo vamos a usar algunas funcionalidades limitadas, y la idea b\u00e1sica no es dif\u00edcil de entender. Combine fue presentado por Apple en la WWDC en junio del 2019. Antes de esto, para usar funcionalidades similares en una aplicaci\u00f3n se pod\u00edan emplear frameworks de terceros como RXSwift o Bond . Sin entrar en si \u00e9stos son mejores o peores que Combine, aqu\u00ed usaremos este \u00faltimo para evitarnos incluir dependencias de terceros, ya que no necesitamos funcionalidades demasiado complejas. MVVM con Combine \u00b6 Vamos a verlo con un ejemplo, ya que as\u00ed se entender\u00e1n mejor los conceptos. Implementaremos una versi\u00f3n MVVM de la aplicaci\u00f3n UAdivino , al estilo de la que hicimos en el apartado anterior, es decir, mostrando cada tipo de respuesta de un color distinto. La diferencia fundamental va a estar en que vincularemos de modo autom\u00e1tico tanto el texto de la respuesta como el color para que no haga falta fijarlos de forma expl\u00edcita en la vista. Esta vinculaci\u00f3n la haremos gracias al framework Combine. El c\u00f3digo fuente est\u00e1 disponible en el repositorio de Github . Vinculaci\u00f3n entre viewmodel y vista \u00b6 Al vincular un origen con un destino lo que hacemos es que cuando el primero cambia, el segundo tambi\u00e9n lo hace autom\u00e1ticamente. Esto simplifica mucho el c\u00f3digo ya que podemos cambiar una propiedad del viewmodel y que se refleje autom\u00e1ticamente en la vista, o viceversa. En nuestro ejemplo del UAdivino queremos vincular dos propiedades del viewmodel con la vista: el texto de la respuesta y el color de la misma. En Combine los bindings se basan en la idea de Publishers y Subscribers . Esta es una idea similar a la de los eventos. Podemos indicar que queremos suscribirnos a un publisher de modo que se nos \"avisar\u00e1\" de cu\u00e1ndo \u00e9ste \"emita\" su valor. Lo m\u00e1s interesante es que los publisher pueden ser simplemente variables, y simplemente cambiar su valor hace que \u00e9ste se \"publique\". Una idea adicional que como veremos es muy potente es que adem\u00e1s la informaci\u00f3n que emiten los publisher se puede manipular, transformar y combinar con diversos operadores, permiti\u00e9ndonos realizar tareas complejas de modo relativamente sencillo. Estas ideas no son exclusivas de Combine, sino que como hemos dicho son las que est\u00e1n tras el paradigma de programaci\u00f3n funcional reactiva , aunque en este paradigma se suele usar una terminolog\u00eda distinta, hablando a veces de observables en lugar de publishers o streams en lugar de events . Si ten\u00e9is inter\u00e9s en el tema pod\u00e9is consultar esta fant\u00e1stica introducci\u00f3n , que aunque no est\u00e1 explicada en el contexto de iOS ni en Swift introduce perfectamente las ideas de la programaci\u00f3n funcional reactiva, que son perfectamente aplicables a cualquier lenguaje de desarrollo y cualquier tipo de aplicaci\u00f3n. En el viewmodel \u00b6 As\u00ed, en el viewmodel definiremos el texto de la respuesta y su color como publishers , para poder luego vincularlos a la vista. Esto se hace con la anotaci\u00f3n @Published import Combine ... @ Published var textoResp = \"\" @ Published var colorResp = ColorRespuesta . verde En el ejemplo anterior hemos dado valores iniciales a los publishers para evitar problemas con los valores nil . En la vista \u00b6 En la vista, para vincular el publisher con una propiedad de un elemento de UIKit usamos el m\u00e9todo assign(to:on:) , donde con el to: especificamos cu\u00e1l es la propiedad, y con el on: cu\u00e1l es el elemento. Por ejemplo, queremos vincular el publisher textoRespuesta con la propiedad text de la etiqueta ( UILabel ) respuestaLabel que est\u00e1 en la vista. Eso lo haremos con la siguiente l\u00ednea: viewModel . $ textoResp . assign ( to : \\ . text !, on : respuestaLabel ), A partir de este momento, cada vez que cambie la variable textoRespuesta en el viewmodel se actualizar\u00e1 autom\u00e1ticamente el texto de la etiqueta respuestaLabel . F\u00edjate en que: Usamos la notaci\u00f3n $ para indicar que queremos usar el valor \"publicado\" de $textoResp , es decir, que cada vez que cambie la variable original queremos recibir el nuevo valor Usamos la notaci\u00f3n llamada keypath en Swift para expresar la propiedad de respuestaLabel a vincular. En esta notaci\u00f3n se usa la sintaxis \\.nombre_de_propiedad y si hubiera \"subpropiedades\" se seguir\u00edan concatenendo con puntos. Esta notaci\u00f3n permite comprobar en tiempo de compilaci\u00f3n que la propiedad es correcta, en lugar de poner una cadena que habr\u00eda que evaluar en tiempo de ejecuci\u00f3n. Finalmente hemos tenido que poner el ! para desempaquetar el opcional, ya que el text de un UILabel es un opcional. Finalmente n\u00f3tese que en debemos almacenar la vinculaci\u00f3n o binding en una variable miembro de la clase UAdivinoView . Esto lo hacemos para que las vinculaciones no se pierdan mientras esta variable est\u00e9 definida (como la vista est\u00e1 \"viva\" durante todo el ciclo de vida de la app pasar\u00e1 lo mismo con la variable miembro). //En el viewmodel private var bindingRespuesta = AnyCancellable ! ... override func viewDidLoad () { super . viewDidLoad () bindingRespuesta = viewModel . $ textoResp . assign ( to : \\ . text !, on : respuestaLabel ) } Transformar los valores de un publisher \u00b6 Nos queda por vincular el publisher colorResp con la propiedad textColor de la etiqueta respuestaLabel . Sin embargo aqu\u00ed tenemos un problema: colorResp es de un tipo definido por nosotros, ColorRespuesta , mientras que textColor es un tipo propio de UIKit . Por lo tanto no podemos aplicar directamente el assign(to:on) . Podr\u00edamos representar los colores en el viewmodel con UIColor para evitarnos esta discordancia de tipos, pero recordemos que el viewmodel no deber\u00eda contener c\u00f3digo de UIKit . Una idea bastante poderosa de los publishers es que los eventos que emiten se pueden transformar y adem\u00e1s de modo encadenado. Para ello se pueden usar las primitivas t\u00edpicas de programaci\u00f3n funcional ( map , filter ,...) y adem\u00e1s algunas adicionales (de ah\u00ed viene precisamente el apelativo de \"funcional\" de la programaci\u00f3n funcional reactiva). Por tanto lo que haremos ser\u00e1 transformar el evento en uno de tipo UIColor y vincular el color del label con este. En la vista har\u00edamos algo como: viewModel . $ colorResp . map { color in color == ColorRespuesta . verde ? UIColor . green : UIColor . red } . assign ( to : \\ . textColor !, on : respuestaLabel ) Recordemos que la primitiva map transforma un valor en otro. Vinculaci\u00f3n de vista a viewmodel \u00b6 En el ejemplo de UAdivino no hay ning\u00fan caso de uso de vinculaci\u00f3n en la direcci\u00f3n contraria, es decir, de la vista hacia el viewmodel , as\u00ed que pondremos otro ejemplo. Supongamos una app con un campo de texto en que el usuario escribe un texto de b\u00fasqueda. En la vista tendremos definido un outlet que referencie el campo de texto. Nuestro objetivo es detectar cu\u00e1ndo cambia el texto del campo y asignarlo a alguna propiedad del viewmodel . Podemos aprovechar que cada vez que cambia el texto se emite una notificaci\u00f3n del tipo textDidChangeNotification //En la vista let binding : AnyCancellable ! ... func viewDidLoad () { binding = NotificationCenter . default . publisher ( for : UITextField . textDidChangeNotification , object : textoField ) //obtenemos el UITextField que ha cambiado pero nos interesa el texto . compactMap { ( $0 . object as ? UITextField )?. text } //Cambiamos el tipo de evento a \"gen\u00e9rico\" . eraseToAnyPublisher () //asignamos el valor observado a una variable que nos interese . assign ( to : \\ . texto , on : self . viewModel ) } En el ejemplo estamos suponiendo que podemos acceder al viewmodel desde la vista con una variable viewModel (ver el apartado siguiente). Entonces asignamos el valor \"notificado\" a la variable texto del viewmodel . Te\u00f3ricamente esto se deber\u00eda poder hacer de forma mucho m\u00e1s f\u00e1cil simplemente observando los cambios en la propiedad text del campo de texto. Por desgracia aunque observar propiedades se puede hacer con muchos objetos, en la versi\u00f3n actual de iOS esta funcionalidad no se implementa con los UIControl (y UITextField lo es). Hay que decir que en frameworks de terceros como RxSwift esto s\u00ed es posible. \"Ensamblaje\" de modelo, viewmodel y vista \u00b6 Al igual que en el caso de MVP, hay que conectar las \"piezas\": modelo, viewmodel y vista. Como seg\u00fan el esquema del patr\u00f3n la vista \"posee\" al viewmodel , definiremos este como una propiedad de la vista: class UAdivinoView : UIViewController { let viewModel = UAdivinoViewModel () ... } Y como el viewmodel \"posee\" al modelo definiremos este como una propiedad del primero: class UAdivinoViewModel { let model = UAdivinoModel ( nombre : \"Rappel\" ) ... } En MVVM, una parte importante del ensamblaje es inicializar las vinculaciones o bindings . Una forma sencilla de hacer esto es en el viewDidLoad de la vista: override func viewDidLoad () { self . bindViewModel () } func bindViewModel () { //conectamos viewModel.textoResp -> texto del label viewModel . $ textoResp . assign ( to : \\ . text !, on : respuestaLabel ) ... }","title":"MVVM"},{"location":"arquitecturas/4_MVVM/#mvvm-vs-mvp","text":"El patr\u00f3n de dise\u00f1o Model/View/ViewModel es muy similar al MVP que vimos en el apartado anterior. De hecho, el ViewModel tiene m\u00e1s o menos la misma funcionalidad que el presenter , implementar la l\u00f3gica de presentaci\u00f3n y aislarla de la tecnolog\u00eda concreta usada para la presentaci\u00f3n. \u00bfD\u00f3nde est\u00e1 la diferencia entonces?. En que MVVM soluciona uno de los principales problemas que tiene MVP, el acoplamiento entre vista y presenter . Como estuvimos discutiendo, la vista y el presenter deben \"conocerse\" mutuamente, ya que la vista debe comunicarle a este las acciones del usuario, y el presenter enviarle a la vista los datos a mostrar. Ya hemos visto en el c\u00f3digo de ejemplo de MVP que en la vista hay una referencia al presenter y viceversa. Eso quiere decir que no es sencillo cambiar la implementaci\u00f3n de uno de los dos sin afectar al otro. En MVVM no hay acoplamiento entre vista y viewmodel , y lo vamos a evitar usando bindings , es decir, vinculaci\u00f3n autom\u00e1tica entre los datos del viewmodel y la vista, de manera que cuando cambie alguno de ellos se modifique autom\u00e1ticamente la otra. Esto permite que el c\u00f3digo quede mucho m\u00e1s \"limpio\", ya que no hay que actualizar el otro componente de modo expl\u00edcito. En iOS podemos usar el framework Combine para hacer esta vinculaci\u00f3n. Combine es un framework encuadrado en lo que se conoce com\u00fanmente como \"programaci\u00f3n funcional reactiva\". Si no has o\u00eddo nunca este t\u00e9rmino no te preocupes, aqu\u00ed solo vamos a usar algunas funcionalidades limitadas, y la idea b\u00e1sica no es dif\u00edcil de entender. Combine fue presentado por Apple en la WWDC en junio del 2019. Antes de esto, para usar funcionalidades similares en una aplicaci\u00f3n se pod\u00edan emplear frameworks de terceros como RXSwift o Bond . Sin entrar en si \u00e9stos son mejores o peores que Combine, aqu\u00ed usaremos este \u00faltimo para evitarnos incluir dependencias de terceros, ya que no necesitamos funcionalidades demasiado complejas.","title":"MVVM vs. MVP"},{"location":"arquitecturas/4_MVVM/#mvvm-con-combine","text":"Vamos a verlo con un ejemplo, ya que as\u00ed se entender\u00e1n mejor los conceptos. Implementaremos una versi\u00f3n MVVM de la aplicaci\u00f3n UAdivino , al estilo de la que hicimos en el apartado anterior, es decir, mostrando cada tipo de respuesta de un color distinto. La diferencia fundamental va a estar en que vincularemos de modo autom\u00e1tico tanto el texto de la respuesta como el color para que no haga falta fijarlos de forma expl\u00edcita en la vista. Esta vinculaci\u00f3n la haremos gracias al framework Combine. El c\u00f3digo fuente est\u00e1 disponible en el repositorio de Github .","title":"MVVM con Combine"},{"location":"arquitecturas/4_MVVM/#vinculacion-entre-viewmodel-y-vista","text":"Al vincular un origen con un destino lo que hacemos es que cuando el primero cambia, el segundo tambi\u00e9n lo hace autom\u00e1ticamente. Esto simplifica mucho el c\u00f3digo ya que podemos cambiar una propiedad del viewmodel y que se refleje autom\u00e1ticamente en la vista, o viceversa. En nuestro ejemplo del UAdivino queremos vincular dos propiedades del viewmodel con la vista: el texto de la respuesta y el color de la misma. En Combine los bindings se basan en la idea de Publishers y Subscribers . Esta es una idea similar a la de los eventos. Podemos indicar que queremos suscribirnos a un publisher de modo que se nos \"avisar\u00e1\" de cu\u00e1ndo \u00e9ste \"emita\" su valor. Lo m\u00e1s interesante es que los publisher pueden ser simplemente variables, y simplemente cambiar su valor hace que \u00e9ste se \"publique\". Una idea adicional que como veremos es muy potente es que adem\u00e1s la informaci\u00f3n que emiten los publisher se puede manipular, transformar y combinar con diversos operadores, permiti\u00e9ndonos realizar tareas complejas de modo relativamente sencillo. Estas ideas no son exclusivas de Combine, sino que como hemos dicho son las que est\u00e1n tras el paradigma de programaci\u00f3n funcional reactiva , aunque en este paradigma se suele usar una terminolog\u00eda distinta, hablando a veces de observables en lugar de publishers o streams en lugar de events . Si ten\u00e9is inter\u00e9s en el tema pod\u00e9is consultar esta fant\u00e1stica introducci\u00f3n , que aunque no est\u00e1 explicada en el contexto de iOS ni en Swift introduce perfectamente las ideas de la programaci\u00f3n funcional reactiva, que son perfectamente aplicables a cualquier lenguaje de desarrollo y cualquier tipo de aplicaci\u00f3n.","title":"Vinculaci\u00f3n entre viewmodel y vista"},{"location":"arquitecturas/4_MVVM/#ensamblaje-de-modelo-viewmodel-y-vista","text":"Al igual que en el caso de MVP, hay que conectar las \"piezas\": modelo, viewmodel y vista. Como seg\u00fan el esquema del patr\u00f3n la vista \"posee\" al viewmodel , definiremos este como una propiedad de la vista: class UAdivinoView : UIViewController { let viewModel = UAdivinoViewModel () ... } Y como el viewmodel \"posee\" al modelo definiremos este como una propiedad del primero: class UAdivinoViewModel { let model = UAdivinoModel ( nombre : \"Rappel\" ) ... } En MVVM, una parte importante del ensamblaje es inicializar las vinculaciones o bindings . Una forma sencilla de hacer esto es en el viewDidLoad de la vista: override func viewDidLoad () { self . bindViewModel () } func bindViewModel () { //conectamos viewModel.textoResp -> texto del label viewModel . $ textoResp . assign ( to : \\ . text !, on : respuestaLabel ) ... }","title":"\"Ensamblaje\" de modelo, viewmodel y vista"},{"location":"arquitecturas/5_VIPER/","text":"MVP y MVVM son un paso m\u00e1s en la separaci\u00f3n de responsabilidades en los componentes de la aplicaci\u00f3n, pero no dejan claro c\u00f3mo estructurar el modelo. Adem\u00e1s algunas cosas quedan fuera de la arquitectura, como es el caso del cambio de pantallas en la aplicaci\u00f3n: t\u00edpicamente habr\u00e1 un MVVM por cada pantalla, pero \u00bfqui\u00e9n decide a d\u00f3nde ir saltando y c\u00f3mo hacerlo?. VIPER (View/Interactor/Presenter/Entity/Router) es una arquitectura que intenta solucionar o al menos abordar estos problemas. VIPER es una adaptaci\u00f3n a iOS de la Clean Architecture propuesta por el \"gur\u00fa\" de la ingenier\u00eda del software Robert C. Martin , conocido familiarmente como \"Uncle Bob\". El t\u00edo Bob ha explicado los detalles de su clean architecture en m\u00faltiples ocasiones, por ejemplo en su blog y en algunas charlas . VIPER aparece descrito por primera vez en este art\u00edculo de 2014. Igual que suced\u00eda con los \"controladores ligeros\" en MVC, una de las ideas b\u00e1sicas de la Clean Architecture y por tanto de VIPER es llevar a la pr\u00e1ctica el \"Principio de \u00danica Responsabilidad\". Componentes de la arquitectura \u00b6 Como hemos enumerado antes, los componentes son los siguientes: View : muestra los datos que le pasa el presenter , y le pasa a este las acciones del usuario. Como vemos es el mismo papel que desempe\u00f1a en MVP o MVVM. Interactor : es la l\u00f3gica de negocio, los casos de uso de nuestra aplicaci\u00f3n. T\u00edpicamente cada m\u00f3dulo VIPER implementar\u00e1 un caso de uso distinto. Presenter : contiene la l\u00f3gica de presentaci\u00f3n, al igual que en MVP. Entity : los modelos del dominio. Se podr\u00eda decir que contienen la l\u00f3gica de negocio \"gen\u00e9rica\" mientras que el interactor contiene la l\u00f3gica propia de nuestra aplicaci\u00f3n. Router : contiene la l\u00f3gica de navegaci\u00f3n, para saber qu\u00e9 pantallas mostrar y c\u00f3mo cambiar entre ellas. En algunos sitios se conoce tambi\u00e9n como wireframe Los componentes se comunican entre s\u00ed seg\u00fan se indica en el siguiente diagrama: Principios b\u00e1sicos de VIPER \u00b6 Adem\u00e1s de los componentes que lo forman y la forma de comunicarse entre ellos, hay unas cuantas ideas adicionales importantes en VIPER. La primera de ellas es que todos los componentes se comunican entre s\u00ed a trav\u00e9s de protocolos (o interfaces, como dir\u00edamos en otros lenguajes). Esto hace posible sustituir una implementaci\u00f3n de un componente por otra sin afectar al resto del componentes. Es decir, seguimos el principio b\u00e1sico del desarrollo software de programar contra interfaces y no contra implementaciones . En la clean architecture original se hablaba de dos tipos de interfaces: input ports y output ports , y en la mayor\u00eda de implementaciones de VIPER se ha conservado esta idea y terminolog\u00eda. Para un componente, su input port lo constituyen las operaciones que \u00e9l implementa, y que ser\u00e1n llamadas desde otros componentes. El output port ser\u00e1n las operaciones que el componente necesita, implementadas por otro componente. Si tenemos dos componentes, A y B, y A necesita de B, el output port de A ser\u00e1 el mismo protocolo o interfaz que el input port de B. La misi\u00f3n de estos output ports es conseguir lo que se llama inversi\u00f3n de dependencias . Veamos qu\u00e9 es esto. Si nos fijamos en el diagrama principal de VIPER veremos que conforme nos movemos de izquierda a derecha vamos yendo de lo m\u00e1s \"concreto\" y poco reutilizable a lo m\u00e1s \"abstracto\", reutilizable e independiente de los APIs de iOS. La vista est\u00e1 totalmente atada a UIKit , mientras que en el otro extremo el Interactor deber\u00eda ser igual para cualquier plataforma, salvo por el hecho de estar escrito en Swift. Si pensamos en los componentes como capas (m\u00e1s internas conforme avanzamos hacia la derecha), es adecuado que un componente de una capa dependa de los de las capas internas, pero no a la inversa, ya que estar\u00edamos haci\u00e9ndolo depender de \"detalles de implementaci\u00f3n\" que est\u00e1n por debajo de su nivel de abstracci\u00f3n: un ejemplo: cuando el interactor termina su trabajo y debe devolver los datos al presenter tiene que llamarlo para pas\u00e1rselos, pero para no introducir dependencias incorrectas debe hacerlo a trav\u00e9s de un protocolo. Y adem\u00e1s este protocolo deber\u00eda implementarse en el \"paquete\" del interactor , para evitar dependencias directas de c\u00f3digo de interactor a presenter . Este protocolo ser\u00eda el InteractorOutput . Y esto se llama inversi\u00f3n de dependencias porque aunque el interactor llama al presenter en c\u00f3digo no depende de \u00e9l. Otra idea importante es qu\u00e9 datos se pasan entre los componentes . Vamos a verlo con un ejemplo. Si estamos haciendo una aplicaci\u00f3n de tareas pendientes probablemente tendremos una entidad llamada Tarea . Por ejemplo, cuando listamos las tareas pendientes las recuperar\u00e1 el interactor (quiz\u00e1 usando Core Data), que se las pasar\u00e1 al presenter (que formatear\u00e1 los datos adecuadamente, por ejemplo las fechas), y este a su vez a la vista para que las muestre en pantalla. Probablemente lo m\u00e1s directo ser\u00eda pasar objetos Tarea de un componente a otro, pero esto tiene el problema de que estamos acopl\u00e1ndolos todos a la entidad, y si cambiamos esta tendremos que cambiar todos los componentes. Por eso en VIPER y en clean architecture se recomienda pasar solamente los datos que se necesiten y adem\u00e1s en un formato ad hoc , t\u00edpicamente structs o tuplas de datos. Ventajas e inconvenientes \u00b6 Las ventajas de VIPER son las de cualquier arquitectura bien dise\u00f1ada: Facilita la colaboraci\u00f3n en el equipo de desarrollo, si cada desarrollador se ocupa de un componente separado o un conjunto de componentes. Facilita el mantenimiento de la aplicaci\u00f3n. Hace posible el testing . Como inconveniente principal est\u00e1 la sobrecarga que supone crear un m\u00ednimo de 5 componentes por cada m\u00f3dulo. Es una arquitectura que para aplicaciones peque\u00f1as o para aplicaciones implementadas por un solo desarrollador quiz\u00e1 presenta una complicaci\u00f3n excesiva.","title":"VIPER"},{"location":"arquitecturas/5_VIPER/#componentes-de-la-arquitectura","text":"Como hemos enumerado antes, los componentes son los siguientes: View : muestra los datos que le pasa el presenter , y le pasa a este las acciones del usuario. Como vemos es el mismo papel que desempe\u00f1a en MVP o MVVM. Interactor : es la l\u00f3gica de negocio, los casos de uso de nuestra aplicaci\u00f3n. T\u00edpicamente cada m\u00f3dulo VIPER implementar\u00e1 un caso de uso distinto. Presenter : contiene la l\u00f3gica de presentaci\u00f3n, al igual que en MVP. Entity : los modelos del dominio. Se podr\u00eda decir que contienen la l\u00f3gica de negocio \"gen\u00e9rica\" mientras que el interactor contiene la l\u00f3gica propia de nuestra aplicaci\u00f3n. Router : contiene la l\u00f3gica de navegaci\u00f3n, para saber qu\u00e9 pantallas mostrar y c\u00f3mo cambiar entre ellas. En algunos sitios se conoce tambi\u00e9n como wireframe Los componentes se comunican entre s\u00ed seg\u00fan se indica en el siguiente diagrama:","title":"Componentes de la arquitectura"},{"location":"arquitecturas/5_VIPER/#principios-basicos-de-viper","text":"Adem\u00e1s de los componentes que lo forman y la forma de comunicarse entre ellos, hay unas cuantas ideas adicionales importantes en VIPER. La primera de ellas es que todos los componentes se comunican entre s\u00ed a trav\u00e9s de protocolos (o interfaces, como dir\u00edamos en otros lenguajes). Esto hace posible sustituir una implementaci\u00f3n de un componente por otra sin afectar al resto del componentes. Es decir, seguimos el principio b\u00e1sico del desarrollo software de programar contra interfaces y no contra implementaciones . En la clean architecture original se hablaba de dos tipos de interfaces: input ports y output ports , y en la mayor\u00eda de implementaciones de VIPER se ha conservado esta idea y terminolog\u00eda. Para un componente, su input port lo constituyen las operaciones que \u00e9l implementa, y que ser\u00e1n llamadas desde otros componentes. El output port ser\u00e1n las operaciones que el componente necesita, implementadas por otro componente. Si tenemos dos componentes, A y B, y A necesita de B, el output port de A ser\u00e1 el mismo protocolo o interfaz que el input port de B. La misi\u00f3n de estos output ports es conseguir lo que se llama inversi\u00f3n de dependencias . Veamos qu\u00e9 es esto. Si nos fijamos en el diagrama principal de VIPER veremos que conforme nos movemos de izquierda a derecha vamos yendo de lo m\u00e1s \"concreto\" y poco reutilizable a lo m\u00e1s \"abstracto\", reutilizable e independiente de los APIs de iOS. La vista est\u00e1 totalmente atada a UIKit , mientras que en el otro extremo el Interactor deber\u00eda ser igual para cualquier plataforma, salvo por el hecho de estar escrito en Swift. Si pensamos en los componentes como capas (m\u00e1s internas conforme avanzamos hacia la derecha), es adecuado que un componente de una capa dependa de los de las capas internas, pero no a la inversa, ya que estar\u00edamos haci\u00e9ndolo depender de \"detalles de implementaci\u00f3n\" que est\u00e1n por debajo de su nivel de abstracci\u00f3n: un ejemplo: cuando el interactor termina su trabajo y debe devolver los datos al presenter tiene que llamarlo para pas\u00e1rselos, pero para no introducir dependencias incorrectas debe hacerlo a trav\u00e9s de un protocolo. Y adem\u00e1s este protocolo deber\u00eda implementarse en el \"paquete\" del interactor , para evitar dependencias directas de c\u00f3digo de interactor a presenter . Este protocolo ser\u00eda el InteractorOutput . Y esto se llama inversi\u00f3n de dependencias porque aunque el interactor llama al presenter en c\u00f3digo no depende de \u00e9l. Otra idea importante es qu\u00e9 datos se pasan entre los componentes . Vamos a verlo con un ejemplo. Si estamos haciendo una aplicaci\u00f3n de tareas pendientes probablemente tendremos una entidad llamada Tarea . Por ejemplo, cuando listamos las tareas pendientes las recuperar\u00e1 el interactor (quiz\u00e1 usando Core Data), que se las pasar\u00e1 al presenter (que formatear\u00e1 los datos adecuadamente, por ejemplo las fechas), y este a su vez a la vista para que las muestre en pantalla. Probablemente lo m\u00e1s directo ser\u00eda pasar objetos Tarea de un componente a otro, pero esto tiene el problema de que estamos acopl\u00e1ndolos todos a la entidad, y si cambiamos esta tendremos que cambiar todos los componentes. Por eso en VIPER y en clean architecture se recomienda pasar solamente los datos que se necesiten y adem\u00e1s en un formato ad hoc , t\u00edpicamente structs o tuplas de datos.","title":"Principios b\u00e1sicos de VIPER"},{"location":"arquitecturas/5_VIPER/#ventajas-e-inconvenientes","text":"Las ventajas de VIPER son las de cualquier arquitectura bien dise\u00f1ada: Facilita la colaboraci\u00f3n en el equipo de desarrollo, si cada desarrollador se ocupa de un componente separado o un conjunto de componentes. Facilita el mantenimiento de la aplicaci\u00f3n. Hace posible el testing . Como inconveniente principal est\u00e1 la sobrecarga que supone crear un m\u00ednimo de 5 componentes por cada m\u00f3dulo. Es una arquitectura que para aplicaciones peque\u00f1as o para aplicaciones implementadas por un solo desarrollador quiz\u00e1 presenta una complicaci\u00f3n excesiva.","title":"Ventajas e inconvenientes"},{"location":"arquitecturas/6_ejercicios/","text":"Queremos hacer una aplicaci\u00f3n con arquitectura MVVM para consultar el tiempo meteorol\u00f3gico. El proyecto con la plantilla est\u00e1 en moodle. Ya tiene creadas las \"carpetas\" y los esqueletos de c\u00f3digo para la vista, el modelo y el viewmodel . De hecho el modelo ya est\u00e1 terminado y no es necesario que modifiques nada de TiempoModel.swift , aunque s\u00ed tendr\u00e1s que completar la vista ( MainView.swift ) y el viewmodel ( ViewModel.swift ) Ensamblaje de vista, modelo y viewmodel \u00b6 En la clase de la vista ( MainView ) a\u00f1adir una propiedad que represente al viewmodel let viewModel = TiempoViewModel () En el TiempoViewModel a\u00f1adir una propiedad que represente al modelo let modelo = TiempoModelo () Mostrar la descripci\u00f3n del tiempo (0,5 puntos) \u00b6 En este apartado conseguiremos que al pulsar en el bot\u00f3n \"consultar tiempo\" la descripci\u00f3n en modo texto (p.ej. \"sol\") aparezca en la pantalla del dispositivo. En el viewmodel : TiempoViewModel A\u00f1ade al comienzo un import Combine Crea la propiedad que representa el estado actual del tiempo, estado de tipo String, asign\u00e1ndole como valor inicial la cadena vac\u00eda Anota la propiedad con @Published para que se publiquen los cambios crea el siguiente m\u00e9todo, que llamar\u00e1 al modelo para consultar el tiempo actual func consultarTiempoActual ( localidad : String ) { modelo . consultarTiempoActual ( localidad : localidad ) { estado , urlIcono in OperationQueue . main . addOperation { //como al tocar estas propiedades se va a modificar la interfaz //debemos hacerlo desde el hilo principal self . estado = estado //de momento no hacemos nada con `urlIcono` } } } F\u00edjate que esta funci\u00f3n le \"pasa la pelota al modelo\". Al ser una operaci\u00f3n as\u00edncrona, tras obtener la informaci\u00f3n, el modelo ejecuta la clausura que se le pasa como par\u00e1metro. Aqu\u00ed lo que hacemos es copiar el texto del estado en la propiedad del viewmodel del mismo nombre. En la vista: MainView A\u00f1ade al comienzo un import Combine En el viewDidLoad() vincula la propiedad estado del viewmodel con la propiedad text del label estadoLabel Ten en cuenta que debes guardar esta vinculaci\u00f3n en alguna variable que sea una propiedad del viewModel para que no se \"pierda\" y se mantenga \"activa\" Haz que en el m\u00e9todo botonPulsado se llame a consultarTiempoActual(localidad:) del viewmodel , pas\u00e1ndole como par\u00e1metro lo que haya escrito el el campo de texto campoTexto . Si todo es correcto, al probar la app , escribir una localidad en el campo de texto y pulsar sobre el bot\u00f3n de \"Ver tiempo\" deber\u00eda aparecer la descripci\u00f3n con el estado actual del tiempo en la pantalla del dispositivo. Mostrar el icono del tiempo (0,5 puntos) \u00b6 Haz lo mismo para el icono del tiempo. Intenta hacer todos los pasos por t\u00ed mismo, ser\u00e1n similares al apartado anterior, solo que ser\u00e1 m\u00e1s complicado ya que queremos vincular lo que en origen es un String con la URL a la que hay que acceder para obtener el icono del tiempo. Tendr\u00e1s que hacer las siguientes transformaciones: Filtrar que la URL del icono sea distinta a la cadena vac\u00eda. (operador filter ) Con el operador map convertir el String con la URL del icono a una UIImage . Tienes que hacerlo en varios pasos: String -> objeto de la clase URL -> datos binarios -> imagen let url = URL ( string : lo_que_sea_la_cadena_con_la_URL ) let datos = try ! Data ( contentsOf : url !) return UIImage ( data : datos )","title":"Ejercicios. App con MVVM"},{"location":"arquitecturas/6_ejercicios/#ensamblaje-de-vista-modelo-y-viewmodel","text":"En la clase de la vista ( MainView ) a\u00f1adir una propiedad que represente al viewmodel let viewModel = TiempoViewModel () En el TiempoViewModel a\u00f1adir una propiedad que represente al modelo let modelo = TiempoModelo ()","title":"Ensamblaje de vista, modelo y viewmodel"},{"location":"arquitecturas/6_ejercicios/#mostrar-la-descripcion-del-tiempo-05-puntos","text":"En este apartado conseguiremos que al pulsar en el bot\u00f3n \"consultar tiempo\" la descripci\u00f3n en modo texto (p.ej. \"sol\") aparezca en la pantalla del dispositivo. En el viewmodel : TiempoViewModel A\u00f1ade al comienzo un import Combine Crea la propiedad que representa el estado actual del tiempo, estado de tipo String, asign\u00e1ndole como valor inicial la cadena vac\u00eda Anota la propiedad con @Published para que se publiquen los cambios crea el siguiente m\u00e9todo, que llamar\u00e1 al modelo para consultar el tiempo actual func consultarTiempoActual ( localidad : String ) { modelo . consultarTiempoActual ( localidad : localidad ) { estado , urlIcono in OperationQueue . main . addOperation { //como al tocar estas propiedades se va a modificar la interfaz //debemos hacerlo desde el hilo principal self . estado = estado //de momento no hacemos nada con `urlIcono` } } } F\u00edjate que esta funci\u00f3n le \"pasa la pelota al modelo\". Al ser una operaci\u00f3n as\u00edncrona, tras obtener la informaci\u00f3n, el modelo ejecuta la clausura que se le pasa como par\u00e1metro. Aqu\u00ed lo que hacemos es copiar el texto del estado en la propiedad del viewmodel del mismo nombre. En la vista: MainView A\u00f1ade al comienzo un import Combine En el viewDidLoad() vincula la propiedad estado del viewmodel con la propiedad text del label estadoLabel Ten en cuenta que debes guardar esta vinculaci\u00f3n en alguna variable que sea una propiedad del viewModel para que no se \"pierda\" y se mantenga \"activa\" Haz que en el m\u00e9todo botonPulsado se llame a consultarTiempoActual(localidad:) del viewmodel , pas\u00e1ndole como par\u00e1metro lo que haya escrito el el campo de texto campoTexto . Si todo es correcto, al probar la app , escribir una localidad en el campo de texto y pulsar sobre el bot\u00f3n de \"Ver tiempo\" deber\u00eda aparecer la descripci\u00f3n con el estado actual del tiempo en la pantalla del dispositivo.","title":"Mostrar la descripci\u00f3n del tiempo (0,5 puntos)"},{"location":"arquitecturas/6_ejercicios/#mostrar-el-icono-del-tiempo-05-puntos","text":"Haz lo mismo para el icono del tiempo. Intenta hacer todos los pasos por t\u00ed mismo, ser\u00e1n similares al apartado anterior, solo que ser\u00e1 m\u00e1s complicado ya que queremos vincular lo que en origen es un String con la URL a la que hay que acceder para obtener el icono del tiempo. Tendr\u00e1s que hacer las siguientes transformaciones: Filtrar que la URL del icono sea distinta a la cadena vac\u00eda. (operador filter ) Con el operador map convertir el String con la URL del icono a una UIImage . Tienes que hacerlo en varios pasos: String -> objeto de la clase URL -> datos binarios -> imagen let url = URL ( string : lo_que_sea_la_cadena_con_la_URL ) let datos = try ! Data ( contentsOf : url !) return UIImage ( data : datos )","title":"Mostrar el icono del tiempo (0,5 puntos)"},{"location":"arquitecturas/6a_ejercicios1/","text":"Ejercicios de arquitecturas iOS, parte I \u00b6 En la aplicaci\u00f3n de Notas que venimos desarrollando en la asignatura, el view controller ListaNotasController tiene demasiadas funcionalidades. (4 puntos) Separa los m\u00e9todos que implementan el datasource de la tabla en una clase aparte: - Crea la clase ListaNotasDatasource : - A\u00f1\u00e1dele un m\u00e9todo setLista() que reciba un array de notas ( [Nota] ) como par\u00e1metro y se lo guarde en una propiedad de la clase llamada listaNotas - Ll\u00e9vate a esta clase el c\u00f3digo de los m\u00e9todos que implementan el datasource - En el ListaNotasViewController - A\u00f1ade una propiedad ds , de tipo ListaNotasDataSource - En el viewDidLoad , haz que el ds sea el datasource de la tabla 1 2 3 4 5 6 ` `` swift self.tableView.dataSource = self.ds `` ` - En el `viewWillAppear` , cada vez que obtengas la lista de notas con el * fetch request * , p\u00e1saselas al `ds` , con `ds.setLista()` - La propiedad `listaNotas` del `ListaNotasViewController` ya sobra , porque la lista ahora la maneja el * datasource * (1 punto) En el ListaNotasDatasource separa el c\u00f3digo que se encarga de rellenar los campos de la celda y encaps\u00falalo en una clase aparte igual que se muestra en las transparencias","title":"6a ejercicios1"},{"location":"arquitecturas/6a_ejercicios1/#ejercicios-de-arquitecturas-ios-parte-i","text":"En la aplicaci\u00f3n de Notas que venimos desarrollando en la asignatura, el view controller ListaNotasController tiene demasiadas funcionalidades. (4 puntos) Separa los m\u00e9todos que implementan el datasource de la tabla en una clase aparte: - Crea la clase ListaNotasDatasource : - A\u00f1\u00e1dele un m\u00e9todo setLista() que reciba un array de notas ( [Nota] ) como par\u00e1metro y se lo guarde en una propiedad de la clase llamada listaNotas - Ll\u00e9vate a esta clase el c\u00f3digo de los m\u00e9todos que implementan el datasource - En el ListaNotasViewController - A\u00f1ade una propiedad ds , de tipo ListaNotasDataSource - En el viewDidLoad , haz que el ds sea el datasource de la tabla 1 2 3 4 5 6 ` `` swift self.tableView.dataSource = self.ds `` ` - En el `viewWillAppear` , cada vez que obtengas la lista de notas con el * fetch request * , p\u00e1saselas al `ds` , con `ds.setLista()` - La propiedad `listaNotas` del `ListaNotasViewController` ya sobra , porque la lista ahora la maneja el * datasource * (1 punto) En el ListaNotasDatasource separa el c\u00f3digo que se encarga de rellenar los campos de la celda y encaps\u00falalo en una clase aparte igual que se muestra en las transparencias","title":"Ejercicios de arquitecturas iOS, parte I"},{"location":"arquitecturas/7_ejercicios_SwiftUI/","text":"El ejercicio completo se punt\u00faa con 1 punto El objetivo del ejercicio es implementar la app del tiempo pero ahora con SwiftUI. Para ahorrar algo de tiempo coge la plantilla de proyecto de la sesi\u00f3n. Consejos: En general, intenta que primero se vea el texto con el estado del tiempo y una vez est\u00e9 funcionando oc\u00fapate del icono con la imagen, recuerda que este \u00faltimo hay que cargarlo desde una url y la cosa se complica un poco con \u00e9l. F\u00edjate en la transparencia con el ejemplo de formulario Puedes por ejemplo hacer dos secciones, una para el campo de texto donde se escribe la localidad y el bot\u00f3n y otra para mostrar los resultados en forma de texto y en forma gr\u00e1fica Los resultados solo los debes mostrar si no est\u00e1n vac\u00edos, mira en la traspa c\u00f3mo se hace para mostrar componentes de manera condicional Para comunicarnos con el servidor podemos reutilizar el c\u00f3digo del modelo de la versi\u00f3n sin SwiftUI. Para consultar el tiempo necesitas crear una instancia de TiempoModelo y sobre ella llamar al m\u00e9todo consultarTiempoActual(localidad:callback:) let modelo = TiempoModelo () ... modelo . consultarTiempoActual ( localidad : localidad ) { texto , direccionIcono in //a partir de aqu\u00ed, asignar \"texto\" y \"direccionIcono\" a propiedades @State //para que se repinte la vista //Ojo, tendr\u00e1s que transformar direccionIcono String -> URL -> Data -> UIImage }","title":"Ejercicios. SwiftUI"},{"location":"arquitecturas/intro/","text":"En este tema veremos algo que no est\u00e1 directamente relacionado con la persistencia, pero que es pertinente en este punto del curso. Hasta ahora hemos visto multitud de tecnolog\u00edas para desarrollar aplicaciones en iOS, pero una cosa que nos falta es saber c\u00f3mo estructurar el c\u00f3digo de la aplicaci\u00f3n para hacerlo lo m\u00e1s claro, mantenible y testable que sea posible. Ya vimos al comienzo del curso que la arquitectura recomendada por Apple es Modelo/Vista/Controlador, pero aunque es muy apropiada para ejemplos y para aplicaciones peque\u00f1as, con aplicaciones m\u00e1s grandes presenta algunos problemas. Primero veremos cu\u00e1les son estos problemas y c\u00f3mo solucionarlos aunque sea parcialmente y luego abordaremos otras arquitecturas que se han propuesto como alternativas al cl\u00e1sico MVC.","title":"Intro"},{"location":"arquitecturas/notas/","text":"Los problemas de MVC MVC de Apple: expectativa vs. realidad Adelgazar controladores. \u00bfPero d\u00f3nde ponemos el c\u00f3digo que sobra? MVx Viper Arquitecturas reactivas Referencias \u00b6 MVP \u00b6 http://iyadagha.com/using-mvp-ios-swift/ https://ios.james.ooo/model-view-controller-presenter-8bb4149fa5ef#.b63z6tbjy","title":"Notas"},{"location":"arquitecturas/notas/#referencias","text":"","title":"Referencias"},{"location":"arquitecturas/notas/#mvp","text":"http://iyadagha.com/using-mvp-ios-swift/ https://ios.james.ooo/model-view-controller-presenter-8bb4149fa5ef#.b63z6tbjy","title":"MVP"}]}